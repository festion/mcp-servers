#!/bin/bash

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

source "$SCRIPT_DIR/common/logging.sh"
source "$SCRIPT_DIR/common/utils.sh"

setup_logging

usage() {
    cat << EOF
Usage: $0 [OPTIONS] COMMAND

Automated maintenance scheduler and runner for GitHub Actions runner

COMMANDS:
    install         Install automated maintenance jobs
    uninstall       Remove automated maintenance jobs
    status          Show status of automated maintenance
    run-daily       Execute daily maintenance tasks
    run-weekly      Execute weekly maintenance tasks
    run-monthly     Execute monthly maintenance tasks
    test            Test automated maintenance setup

OPTIONS:
    -h, --help              Show this help message
    --cron-user USER        User to run cron jobs as [default: github-runner]
    --notification-email    Email for maintenance notifications
    --dry-run               Show what would be done without executing
    -v, --verbose           Verbose output

Examples:
    $0 install                          # Install all automated maintenance
    $0 install --cron-user runner       # Install with specific user
    $0 run-daily --dry-run              # Test daily maintenance
    $0 status                           # Check maintenance status
EOF
}

COMMAND=""
CRON_USER="${USER:-github-runner}"
NOTIFICATION_EMAIL=""
DRY_RUN=false
VERBOSE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            exit 0
            ;;
        --cron-user)
            CRON_USER="$2"
            shift 2
            ;;
        --notification-email)
            NOTIFICATION_EMAIL="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            LOG_LEVEL="DEBUG"
            shift
            ;;
        install|uninstall|status|run-daily|run-weekly|run-monthly|test)
            COMMAND="$1"
            shift
            ;;
        *)
            log_error "Unknown option: $1"
            usage
            exit 1
            ;;
    esac
done

if [[ -z "$COMMAND" ]]; then
    log_error "Command is required"
    usage
    exit 1
fi

create_daily_maintenance_script() {
    local script_path="/usr/local/bin/github-runner-daily-maintenance"
    
    log_info "Creating daily maintenance script..."
    
    if [[ "$DRY_RUN" == true ]]; then
        log_info "Would create: $script_path"
        return 0
    fi
    
    cat > "$script_path" << 'EOF'
#!/bin/bash
# GitHub Actions Runner - Daily Maintenance
# Automatically generated by automated-maintenance.sh

set -euo pipefail

SCRIPT_DIR="/opt/github-actions-runner/scripts"
LOG_FILE="/var/log/github-runner/daily-maintenance-$(date +%Y%m%d).log"
LOCK_FILE="/var/lock/github-runner-daily.lock"

# Ensure log directory exists
mkdir -p "$(dirname "$LOG_FILE")"

# Function to log with timestamp
log_with_timestamp() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $*" | tee -a "$LOG_FILE"
}

# Function to send notification
send_maintenance_notification() {
    local status="$1"
    local message="$2"
    
    # Send to system log
    logger -t github-runner-maintenance "$status: $message"
    
    # Send email if configured
    if [[ -n "${NOTIFICATION_EMAIL:-}" ]] && command -v mail >/dev/null 2>&1; then
        echo "$message" | mail -s "GitHub Runner Daily Maintenance - $status" "$NOTIFICATION_EMAIL"
    fi
}

# Check if another instance is running
if [[ -f "$LOCK_FILE" ]]; then
    local lock_pid
    lock_pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
    
    if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
        log_with_timestamp "ERROR: Another daily maintenance is already running (PID: $lock_pid)"
        exit 1
    else
        rm -f "$LOCK_FILE"
    fi
fi

# Create lock file
echo $$ > "$LOCK_FILE"
trap 'rm -f "$LOCK_FILE"' EXIT

log_with_timestamp "Starting daily maintenance..."

cd "$SCRIPT_DIR"

# Daily maintenance tasks
FAILED_TASKS=""

# 1. Health check
log_with_timestamp "Running health check..."
if ./health-check.sh --automated >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Health check: SUCCESS"
else
    log_with_timestamp "Health check: FAILED"
    FAILED_TASKS="health-check $FAILED_TASKS"
fi

# 2. Log cleanup
log_with_timestamp "Running log cleanup..."
if ./maintenance.sh logs --retention-days 7 >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Log cleanup: SUCCESS"
else
    log_with_timestamp "Log cleanup: FAILED"
    FAILED_TASKS="log-cleanup $FAILED_TASKS"
fi

# 3. Basic disk space check
log_with_timestamp "Checking disk space..."
DISK_USAGE=$(df / | awk 'NR==2 {print $5}' | sed 's/%//')
if [[ "$DISK_USAGE" -gt 85 ]]; then
    log_with_timestamp "WARNING: High disk usage detected: ${DISK_USAGE}%"
    
    # Run disk cleanup
    if ./maintenance.sh disk >> "$LOG_FILE" 2>&1; then
        log_with_timestamp "Emergency disk cleanup: SUCCESS"
    else
        log_with_timestamp "Emergency disk cleanup: FAILED"
        FAILED_TASKS="disk-cleanup $FAILED_TASKS"
    fi
else
    log_with_timestamp "Disk usage OK: ${DISK_USAGE}%"
fi

# 4. Docker cleanup (if available)
if command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
    log_with_timestamp "Running Docker cleanup..."
    
    # Clean up stopped containers and unused images
    docker container prune -f >> "$LOG_FILE" 2>&1 || true
    docker image prune -f >> "$LOG_FILE" 2>&1 || true
    
    log_with_timestamp "Docker cleanup: SUCCESS"
fi

# 5. Security check
log_with_timestamp "Running basic security check..."
if "$SCRIPT_DIR/../security/scripts/security-monitor.sh" --quick-check >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Security check: SUCCESS"
else
    log_with_timestamp "Security check: FAILED"
    FAILED_TASKS="security-check $FAILED_TASKS"
fi

# 6. Backup verification
log_with_timestamp "Verifying recent backups..."
if ./backup.sh --verify --quiet >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Backup verification: SUCCESS"
else
    log_with_timestamp "Backup verification: FAILED"
    FAILED_TASKS="backup-verification $FAILED_TASKS"
fi

# Summary
log_with_timestamp "Daily maintenance completed"

if [[ -z "$FAILED_TASKS" ]]; then
    log_with_timestamp "All tasks completed successfully"
    send_maintenance_notification "SUCCESS" "Daily maintenance completed successfully on $(hostname)"
else
    log_with_timestamp "Some tasks failed: $FAILED_TASKS"
    send_maintenance_notification "WARNING" "Daily maintenance completed with issues on $(hostname): Failed tasks: $FAILED_TASKS"
fi

# Clean up old log files (keep last 7 days)
find "$(dirname "$LOG_FILE")" -name "daily-maintenance-*.log" -mtime +7 -delete 2>/dev/null || true

log_with_timestamp "Daily maintenance finished"
EOF

    chmod +x "$script_path"
    log_success "Daily maintenance script created: $script_path"
}

create_weekly_maintenance_script() {
    local script_path="/usr/local/bin/github-runner-weekly-maintenance"
    
    log_info "Creating weekly maintenance script..."
    
    if [[ "$DRY_RUN" == true ]]; then
        log_info "Would create: $script_path"
        return 0
    fi
    
    cat > "$script_path" << 'EOF'
#!/bin/bash
# GitHub Actions Runner - Weekly Maintenance
# Automatically generated by automated-maintenance.sh

set -euo pipefail

SCRIPT_DIR="/opt/github-actions-runner/scripts"
LOG_FILE="/var/log/github-runner/weekly-maintenance-$(date +%Y%m%d).log"
LOCK_FILE="/var/lock/github-runner-weekly.lock"

# Ensure log directory exists
mkdir -p "$(dirname "$LOG_FILE")"

# Function to log with timestamp
log_with_timestamp() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $*" | tee -a "$LOG_FILE"
}

# Function to send notification
send_maintenance_notification() {
    local status="$1"
    local message="$2"
    
    # Send to system log
    logger -t github-runner-maintenance "$status: $message"
    
    # Send email if configured
    if [[ -n "${NOTIFICATION_EMAIL:-}" ]] && command -v mail >/dev/null 2>&1; then
        echo "$message" | mail -s "GitHub Runner Weekly Maintenance - $status" "$NOTIFICATION_EMAIL"
    fi
}

# Check if another instance is running
if [[ -f "$LOCK_FILE" ]]; then
    local lock_pid
    lock_pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
    
    if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
        log_with_timestamp "ERROR: Another weekly maintenance is already running (PID: $lock_pid)"
        exit 1
    else
        rm -f "$LOCK_FILE"
    fi
fi

# Create lock file
echo $$ > "$LOCK_FILE"
trap 'rm -f "$LOCK_FILE"' EXIT

log_with_timestamp "Starting weekly maintenance..."

cd "$SCRIPT_DIR"

# Weekly maintenance tasks
FAILED_TASKS=""

# 1. Comprehensive health check
log_with_timestamp "Running comprehensive health check..."
if ./health-check.sh --comprehensive >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Comprehensive health check: SUCCESS"
else
    log_with_timestamp "Comprehensive health check: FAILED"
    FAILED_TASKS="health-check $FAILED_TASKS"
fi

# 2. Security updates check
log_with_timestamp "Checking for security updates..."
if "$SCRIPT_DIR/../security/scripts/security-monitor.sh" --check-updates >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Security updates check: SUCCESS"
else
    log_with_timestamp "Security updates check: FAILED"
    FAILED_TASKS="security-updates $FAILED_TASKS"
fi

# 3. Performance analysis
log_with_timestamp "Running performance analysis..."
if ./maintenance.sh performance >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Performance analysis: SUCCESS"
else
    log_with_timestamp "Performance analysis: FAILED"
    FAILED_TASKS="performance-analysis $FAILED_TASKS"
fi

# 4. Log archival
log_with_timestamp "Archiving old logs..."
if ./maintenance.sh logs --retention-days 30 >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Log archival: SUCCESS"
else
    log_with_timestamp "Log archival: FAILED"
    FAILED_TASKS="log-archival $FAILED_TASKS"
fi

# 5. Backup integrity check
log_with_timestamp "Running backup integrity check..."
if ./backup.sh --integrity-check >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Backup integrity check: SUCCESS"
else
    log_with_timestamp "Backup integrity check: FAILED"
    FAILED_TASKS="backup-integrity $FAILED_TASKS"
fi

# 6. Update checks
log_with_timestamp "Checking for runner updates..."
if ./update.sh --check-runner-version >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Update check: SUCCESS"
else
    log_with_timestamp "Update check: FAILED"
    FAILED_TASKS="update-check $FAILED_TASKS"
fi

# 7. Container image cleanup
if command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
    log_with_timestamp "Running comprehensive Docker cleanup..."
    
    # Remove old images and volumes
    docker image prune -a --filter "until=168h" -f >> "$LOG_FILE" 2>&1 || true
    docker volume prune -f >> "$LOG_FILE" 2>&1 || true
    docker builder prune --filter "until=168h" -f >> "$LOG_FILE" 2>&1 || true
    
    log_with_timestamp "Docker cleanup: SUCCESS"
fi

# 8. Generate weekly report
log_with_timestamp "Generating weekly performance report..."
if command -v jq >/dev/null 2>&1; then
    local report_file="/var/lib/github-runner/weekly-report-$(date +%Y%m%d).json"
    mkdir -p "$(dirname "$report_file")"
    
    cat > "$report_file" << EOREPORT
{
    "timestamp": "$(date -Iseconds)",
    "hostname": "$(hostname)",
    "disk_usage": "$(df / | awk 'NR==2 {print $5}')",
    "memory_usage": "$(free | awk 'NR==2{printf "%.1f%%", $3*100/$2}')",
    "uptime": "$(uptime -p)",
    "failed_tasks": "$FAILED_TASKS",
    "maintenance_type": "weekly"
}
EOREPORT

    log_with_timestamp "Weekly report generated: $report_file"
fi

# Summary
log_with_timestamp "Weekly maintenance completed"

if [[ -z "$FAILED_TASKS" ]]; then
    log_with_timestamp "All tasks completed successfully"
    send_maintenance_notification "SUCCESS" "Weekly maintenance completed successfully on $(hostname)"
else
    log_with_timestamp "Some tasks failed: $FAILED_TASKS"
    send_maintenance_notification "WARNING" "Weekly maintenance completed with issues on $(hostname): Failed tasks: $FAILED_TASKS"
fi

# Clean up old weekly log files (keep last 4 weeks)
find "$(dirname "$LOG_FILE")" -name "weekly-maintenance-*.log" -mtime +28 -delete 2>/dev/null || true

log_with_timestamp "Weekly maintenance finished"
EOF

    chmod +x "$script_path"
    log_success "Weekly maintenance script created: $script_path"
}

create_monthly_maintenance_script() {
    local script_path="/usr/local/bin/github-runner-monthly-maintenance"
    
    log_info "Creating monthly maintenance script..."
    
    if [[ "$DRY_RUN" == true ]]; then
        log_info "Would create: $script_path"
        return 0
    fi
    
    cat > "$script_path" << 'EOF'
#!/bin/bash
# GitHub Actions Runner - Monthly Maintenance
# Automatically generated by automated-maintenance.sh

set -euo pipefail

SCRIPT_DIR="/opt/github-actions-runner/scripts"
LOG_FILE="/var/log/github-runner/monthly-maintenance-$(date +%Y%m).log"
LOCK_FILE="/var/lock/github-runner-monthly.lock"

# Ensure log directory exists
mkdir -p "$(dirname "$LOG_FILE")"

# Function to log with timestamp
log_with_timestamp() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $*" | tee -a "$LOG_FILE"
}

# Function to send notification
send_maintenance_notification() {
    local status="$1"
    local message="$2"
    
    # Send to system log
    logger -t github-runner-maintenance "$status: $message"
    
    # Send email if configured
    if [[ -n "${NOTIFICATION_EMAIL:-}" ]] && command -v mail >/dev/null 2>&1; then
        echo "$message" | mail -s "GitHub Runner Monthly Maintenance - $status" "$NOTIFICATION_EMAIL"
    fi
}

# Check if another instance is running
if [[ -f "$LOCK_FILE" ]]; then
    local lock_pid
    lock_pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
    
    if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
        log_with_timestamp "ERROR: Another monthly maintenance is already running (PID: $lock_pid)"
        exit 1
    else
        rm -f "$LOCK_FILE"
    fi
fi

# Create lock file
echo $$ > "$LOCK_FILE"
trap 'rm -f "$LOCK_FILE"' EXIT

log_with_timestamp "Starting monthly maintenance..."

cd "$SCRIPT_DIR"

# Monthly maintenance tasks
FAILED_TASKS=""

# 1. Full maintenance cycle
log_with_timestamp "Running full maintenance cycle..."
if ./maintenance.sh full --force >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Full maintenance cycle: SUCCESS"
else
    log_with_timestamp "Full maintenance cycle: FAILED"
    FAILED_TASKS="full-maintenance $FAILED_TASKS"
fi

# 2. Security audit
log_with_timestamp "Running security audit..."
if "$SCRIPT_DIR/../security/scripts/security-monitor.sh" --monthly-audit >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Security audit: SUCCESS"
else
    log_with_timestamp "Security audit: FAILED"
    FAILED_TASKS="security-audit $FAILED_TASKS"
fi

# 3. Capacity analysis
log_with_timestamp "Running capacity analysis..."
if "$SCRIPT_DIR/../monitoring/scripts/metrics-collector.sh" --capacity-analysis >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Capacity analysis: SUCCESS"
else
    log_with_timestamp "Capacity analysis: FAILED"
    FAILED_TASKS="capacity-analysis $FAILED_TASKS"
fi

# 4. Configuration audit
log_with_timestamp "Running configuration audit..."
if "$SCRIPT_DIR/../config/validate-config.sh" --comprehensive >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Configuration audit: SUCCESS"
else
    log_with_timestamp "Configuration audit: FAILED"
    FAILED_TASKS="config-audit $FAILED_TASKS"
fi

# 5. Backup strategy review
log_with_timestamp "Reviewing backup strategy..."
if ./backup.sh --strategy-review >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Backup strategy review: SUCCESS"
else
    log_with_timestamp "Backup strategy review: FAILED"
    FAILED_TASKS="backup-review $FAILED_TASKS"
fi

# 6. System updates check
log_with_timestamp "Checking for system updates..."
if [[ $EUID -eq 0 ]]; then
    apt update >> "$LOG_FILE" 2>&1 || true
    
    local security_updates
    security_updates=$(apt list --upgradable 2>/dev/null | grep -c security || echo "0")
    
    if [[ "$security_updates" -gt 0 ]]; then
        log_with_timestamp "Found $security_updates security updates available"
        
        # Apply critical security updates
        if DEBIAN_FRONTEND=noninteractive apt upgrade -y >> "$LOG_FILE" 2>&1; then
            log_with_timestamp "Security updates applied: SUCCESS"
        else
            log_with_timestamp "Security updates applied: FAILED"
            FAILED_TASKS="security-updates $FAILED_TASKS"
        fi
    else
        log_with_timestamp "No security updates available"
    fi
else
    log_with_timestamp "Not running as root - skipping system updates"
fi

# 7. Performance optimization
log_with_timestamp "Running performance optimization..."
if ./maintenance.sh performance --force >> "$LOG_FILE" 2>&1; then
    log_with_timestamp "Performance optimization: SUCCESS"
else
    log_with_timestamp "Performance optimization: FAILED"
    FAILED_TASKS="performance-optimization $FAILED_TASKS"
fi

# 8. Generate monthly report
log_with_timestamp "Generating monthly comprehensive report..."
if command -v jq >/dev/null 2>&1; then
    local report_file="/var/lib/github-runner/monthly-report-$(date +%Y%m).json"
    mkdir -p "$(dirname "$report_file")"
    
    # Collect system metrics
    local disk_info
    disk_info=$(df -h / | awk 'NR==2 {printf "{\"usage\": \"%s\", \"available\": \"%s\", \"total\": \"%s\"}", $5, $4, $2}')
    
    local memory_info
    memory_info=$(free -h | awk 'NR==2{printf "{\"used\": \"%s\", \"available\": \"%s\", \"total\": \"%s\"}", $3, $7, $2}')
    
    local load_avg
    load_avg=$(uptime | awk -F'load average:' '{print $2}' | sed 's/^ *//')
    
    cat > "$report_file" << EOREPORT
{
    "timestamp": "$(date -Iseconds)",
    "hostname": "$(hostname)",
    "maintenance_type": "monthly",
    "failed_tasks": "$FAILED_TASKS",
    "system_metrics": {
        "disk": $disk_info,
        "memory": $memory_info,
        "load_average": "$load_avg",
        "uptime": "$(uptime -p)"
    },
    "runner_status": {
        "service_active": $(systemctl is-active github-runner.service >/dev/null 2>&1 && echo true || echo false),
        "service_enabled": $(systemctl is-enabled github-runner.service >/dev/null 2>&1 && echo true || echo false)
    }
}
EOREPORT

    log_with_timestamp "Monthly report generated: $report_file"
fi

# Summary
log_with_timestamp "Monthly maintenance completed"

if [[ -z "$FAILED_TASKS" ]]; then
    log_with_timestamp "All tasks completed successfully"
    send_maintenance_notification "SUCCESS" "Monthly maintenance completed successfully on $(hostname)"
else
    log_with_timestamp "Some tasks failed: $FAILED_TASKS"
    send_maintenance_notification "WARNING" "Monthly maintenance completed with issues on $(hostname): Failed tasks: $FAILED_TASKS"
fi

# Clean up old monthly log files (keep last 6 months)
find "$(dirname "$LOG_FILE")" -name "monthly-maintenance-*.log" -mtime +180 -delete 2>/dev/null || true

log_with_timestamp "Monthly maintenance finished"
EOF

    chmod +x "$script_path"
    log_success "Monthly maintenance script created: $script_path"
}

install_cron_jobs() {
    log_section "Installing Cron Jobs"
    
    local cron_file="/etc/cron.d/github-runner-maintenance"
    
    if [[ "$DRY_RUN" == true ]]; then
        log_info "Would create cron file: $cron_file"
        return 0
    fi
    
    log_info "Creating cron configuration..."
    
    cat > "$cron_file" << EOF
# GitHub Actions Runner - Automated Maintenance
# Generated by automated-maintenance.sh on $(date)

SHELL=/bin/bash
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
NOTIFICATION_EMAIL=${NOTIFICATION_EMAIL}

# Daily maintenance at 2:30 AM
30 2 * * * $CRON_USER /usr/local/bin/github-runner-daily-maintenance >/dev/null 2>&1

# Weekly maintenance on Sunday at 3:00 AM
0 3 * * 0 $CRON_USER /usr/local/bin/github-runner-weekly-maintenance >/dev/null 2>&1

# Monthly maintenance on the 1st at 1:00 AM
0 1 1 * * $CRON_USER /usr/local/bin/github-runner-monthly-maintenance >/dev/null 2>&1

# Health check every 6 hours
0 */6 * * * $CRON_USER /opt/github-actions-runner/scripts/health-check.sh --automated --quiet >/dev/null 2>&1

# Log rotation check daily at 1:00 AM
0 1 * * * $CRON_USER /usr/sbin/logrotate /etc/logrotate.d/github-runner >/dev/null 2>&1
EOF

    chmod 644 "$cron_file"
    
    # Reload cron
    if command -v systemctl >/dev/null 2>&1; then
        systemctl reload crond 2>/dev/null || systemctl reload cron 2>/dev/null || true
    fi
    
    log_success "Cron jobs installed: $cron_file"
    log_info "Schedule:"
    log_info "  Daily maintenance:   2:30 AM"
    log_info "  Weekly maintenance:  Sunday 3:00 AM"
    log_info "  Monthly maintenance: 1st of month 1:00 AM"
    log_info "  Health checks:       Every 6 hours"
}

uninstall_cron_jobs() {
    log_section "Uninstalling Cron Jobs"
    
    local cron_file="/etc/cron.d/github-runner-maintenance"
    
    if [[ "$DRY_RUN" == true ]]; then
        log_info "Would remove cron file: $cron_file"
        return 0
    fi
    
    if [[ -f "$cron_file" ]]; then
        rm -f "$cron_file"
        log_success "Cron jobs removed: $cron_file"
    else
        log_info "No cron jobs found to remove"
    fi
    
    # Remove maintenance scripts
    local scripts=(
        "/usr/local/bin/github-runner-daily-maintenance"
        "/usr/local/bin/github-runner-weekly-maintenance"
        "/usr/local/bin/github-runner-monthly-maintenance"
    )
    
    for script in "${scripts[@]}"; do
        if [[ -f "$script" ]]; then
            rm -f "$script"
            log_success "Removed: $script"
        fi
    done
    
    # Reload cron
    if command -v systemctl >/dev/null 2>&1; then
        systemctl reload crond 2>/dev/null || systemctl reload cron 2>/dev/null || true
    fi
}

show_maintenance_status() {
    log_section "Automated Maintenance Status"
    
    # Check if cron jobs are installed
    local cron_file="/etc/cron.d/github-runner-maintenance"
    if [[ -f "$cron_file" ]]; then
        log_success "Cron jobs are installed"
        
        # Show next scheduled runs
        if command -v systemctl >/dev/null 2>&1 && systemctl is-active crond >/dev/null 2>&1; then
            log_success "Cron service is active"
        elif command -v systemctl >/dev/null 2>&1 && systemctl is-active cron >/dev/null 2>&1; then
            log_success "Cron service is active"
        else
            log_warn "Cron service may not be running"
        fi
        
        # Show recent maintenance activity
        local log_dir="/var/log/github-runner"
        if [[ -d "$log_dir" ]]; then
            log_info "Recent maintenance logs:"
            
            # Find recent log files
            local recent_logs
            recent_logs=$(find "$log_dir" -name "*maintenance*.log" -mtime -7 2>/dev/null | sort -r | head -5 || echo "")
            
            if [[ -n "$recent_logs" ]]; then
                while IFS= read -r log_file; do
                    local log_age
                    log_age=$(stat -c %y "$log_file" 2>/dev/null | cut -d' ' -f1 || echo "unknown")
                    log_info "  $(basename "$log_file") - $log_age"
                done <<< "$recent_logs"
            else
                log_info "  No recent maintenance logs found"
            fi
        fi
    else
        log_warn "Cron jobs are not installed"
    fi
    
    # Check maintenance scripts
    local scripts=(
        "/usr/local/bin/github-runner-daily-maintenance"
        "/usr/local/bin/github-runner-weekly-maintenance"
        "/usr/local/bin/github-runner-monthly-maintenance"
    )
    
    log_info "Maintenance scripts:"
    for script in "${scripts[@]}"; do
        if [[ -x "$script" ]]; then
            log_success "  $(basename "$script") - installed"
        else
            log_warn "  $(basename "$script") - missing"
        fi
    done
    
    # Check lock files (active maintenance)
    local lock_files=(
        "/var/lock/github-runner-daily.lock"
        "/var/lock/github-runner-weekly.lock"
        "/var/lock/github-runner-monthly.lock"
    )
    
    local active_maintenance=false
    for lock_file in "${lock_files[@]}"; do
        if [[ -f "$lock_file" ]]; then
            local lock_pid
            lock_pid=$(cat "$lock_file" 2>/dev/null || echo "")
            
            if [[ -n "$lock_pid" ]] && kill -0 "$lock_pid" 2>/dev/null; then
                log_info "Active maintenance: $(basename "$lock_file" .lock) (PID: $lock_pid)"
                active_maintenance=true
            fi
        fi
    done
    
    if [[ "$active_maintenance" == false ]]; then
        log_info "No maintenance currently running"
    fi
}

test_maintenance_setup() {
    log_section "Testing Maintenance Setup"
    
    # Test daily maintenance
    log_info "Testing daily maintenance (dry run)..."
    if /usr/local/bin/github-runner-daily-maintenance 2>&1 | tail -5; then
        log_success "Daily maintenance test passed"
    else
        log_warn "Daily maintenance test failed"
    fi
    
    # Test weekly maintenance
    log_info "Testing weekly maintenance (dry run)..."
    if /usr/local/bin/github-runner-weekly-maintenance 2>&1 | tail -5; then
        log_success "Weekly maintenance test passed"
    else
        log_warn "Weekly maintenance test failed"
    fi
    
    # Test cron syntax
    log_info "Testing cron configuration..."
    local cron_file="/etc/cron.d/github-runner-maintenance"
    if [[ -f "$cron_file" ]]; then
        if crontab -T "$cron_file" 2>/dev/null; then
            log_success "Cron configuration is valid"
        else
            log_warn "Cron configuration has issues"
        fi
    else
        log_warn "Cron configuration not found"
    fi
}

main() {
    if [[ $EUID -ne 0 ]]; then
        log_error "This script must be run as root for cron job management"
        exit 1
    fi
    
    log_section "GitHub Actions Runner - Automated Maintenance"
    log_info "Command: $COMMAND"
    log_info "Cron user: $CRON_USER"
    
    case "$COMMAND" in
        install)
            create_daily_maintenance_script
            create_weekly_maintenance_script
            create_monthly_maintenance_script
            install_cron_jobs
            log_success "Automated maintenance installed successfully"
            ;;
        uninstall)
            uninstall_cron_jobs
            log_success "Automated maintenance uninstalled successfully"
            ;;
        status)
            show_maintenance_status
            ;;
        run-daily)
            if [[ "$DRY_RUN" == true ]]; then
                log_info "Daily maintenance dry run..."
                # Run with environment variable to indicate dry run
                DRY_RUN=true /usr/local/bin/github-runner-daily-maintenance || true
            else
                /usr/local/bin/github-runner-daily-maintenance
            fi
            ;;
        run-weekly)
            if [[ "$DRY_RUN" == true ]]; then
                log_info "Weekly maintenance dry run..."
                DRY_RUN=true /usr/local/bin/github-runner-weekly-maintenance || true
            else
                /usr/local/bin/github-runner-weekly-maintenance
            fi
            ;;
        run-monthly)
            if [[ "$DRY_RUN" == true ]]; then
                log_info "Monthly maintenance dry run..."
                DRY_RUN=true /usr/local/bin/github-runner-monthly-maintenance || true
            else
                /usr/local/bin/github-runner-monthly-maintenance
            fi
            ;;
        test)
            test_maintenance_setup
            ;;
        *)
            log_error "Unknown command: $COMMAND"
            exit 1
            ;;
    esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi